/*
 * Copyright (C) 2015 olegvedi@gmail.com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation; either version 2 of
 * the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
 * GNU General Public License for more details.
 *
 */
#define GET_UMP_SECURE_ID_BY_PHY _IOWR('m', 333, unsigned int)
#define FREE_UMP_MEM_BY_ID _IOW('m', 334, unsigned int)

#include "ump_kernel_interface_ref_drv.h"
#include <linux/rk_fb.h>
#include <asm/uaccess.h>
#include <linux/fs.h>
#include <linux/miscdevice.h>

#if 1
#define DDEBUG(fmt, args...)	{printk("%s - " fmt "\n",__func__, ##args);}
#else
#define DDEBUG(...)
#endif


static DEFINE_MUTEX(usi_lock);
static LIST_HEAD(usi_list);

struct usi_reqests {
    struct list_head node;
    ump_dd_physical_block upb;
    ump_dd_handle *umh;
    ump_secure_id secure_id;
};

static ump_secure_id usi_ump_get_secure_id(u32 adr, u32 len)
{
    struct usi_reqests *ureq;
    int find=0;

// FB_MAXPGSIZE;
    mutex_lock(&usi_lock);
    list_for_each_entry(ureq, &usi_list, node) {
	if(ureq->upb.addr == adr && ureq->upb.size == len){
	    find = 1;
	    break;
	}
	if(!(ureq->upb.addr >= (adr + len) || 
		(ureq->upb.addr + ureq->upb.size) <= adr)){ //error mem blocks overlaped
	    DDEBUG("Bufs overlaped");
	    return UMP_INVALID_SECURE_ID;
	}
    }
    mutex_unlock(&usi_lock);

    if(!find){
	ureq = kzalloc(sizeof(*ureq), GFP_KERNEL);
	if(! ureq){
	    DDEBUG("Don`t allocate mem");
	    return UMP_INVALID_SECURE_ID;
        }

	ureq->upb.addr = adr;
	ureq->upb.size = len;

	ureq->umh = ump_dd_handle_create_from_phys_blocks(&ureq->upb, 1);
	ureq->secure_id = ump_dd_secure_id_get(ureq->umh);

	if(ureq->secure_id == UMP_INVALID_SECURE_ID){
	    DDEBUG("Error get secure id");
	    kfree(ureq);
	    return UMP_INVALID_SECURE_ID;
	}

	mutex_lock(&usi_lock);
	list_add_tail(&ureq->node, &usi_list);
	mutex_unlock(&usi_lock);
    }

    DDEBUG("Secure id:%d find:%d",ureq->secure_id, find);
    return ureq->secure_id;
}

static int usi_ump_free_mb(ump_secure_id secure_id)
{
    struct usi_reqests *ureq;
    int find=0,ret=0;

    mutex_lock(&usi_lock);
    list_for_each_entry(ureq, &usi_list, node) {
	if(ureq->secure_id == secure_id){
	    find = 1;
	    break;
	}
    }
    mutex_unlock(&usi_lock);

    if(find){
	DDEBUG("Release mem block");
	while(ureq->umh) //WARNING  it requires change ump kernel driver (ump_dd_reference_release func)
	    ump_dd_reference_release(ureq->umh);
	kfree(ureq);
    }else{
	DDEBUG("Mem block dont found");
	ret = -ENODEV;
    }
    return ret;
}

static long usi_ump_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
{
    unsigned long __user *puser = (unsigned long __user *) arg;
    u32 param[2];

    switch (cmd) {
    case GET_UMP_SECURE_ID_BY_PHY:
	if (copy_from_user(param, &arg, 8))
	    return -EFAULT;
	put_user((unsigned int)usi_ump_get_secure_id(param[0], param[1]), puser);
	return 0;
    case FREE_UMP_MEM_BY_ID:
	if (copy_from_user(param, &arg, 4))
	    return -EFAULT;
	return usi_ump_free_mb(param[0]);;

    }
    return -EFAULT;
}

static const struct file_operations usi_fops = {
    .owner  = THIS_MODULE,
    .unlocked_ioctl = usi_ump_ioctl,
};

static struct miscdevice usi_dev = {
    MISC_DYNAMIC_MINOR,
    "usi_ump",
//    .minor
    &usi_fops
};

static int __init usi_ump_init(void)
{
   int ret;

   ret = misc_register(&usi_dev);
   if(ret)
	printk( KERN_ERR "Unable to register usi_ump\n" );
   return ret;
}

static void __exit usi_ump_exit(void)
{
    struct usi_reqests *ureq;

    list_for_each_entry(ureq, &usi_list, node) {
	if(ureq){
	    while(ureq->umh) //WARNING  it requires change ump kernel driver (ump_dd_reference_release func)
		ump_dd_reference_release(ureq->umh);
	    kfree(ureq);
	}
    }

   misc_deregister(&usi_dev);
}

module_init(usi_ump_init);
module_exit(usi_ump_exit);
MODULE_AUTHOR("olegvedi@gmail.com");
MODULE_LICENSE("GPL");
